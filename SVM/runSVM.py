"""
runSVM.py
Ben Nissan

Trains and tests support vector machines (or SVMs) with libsvm to classify a set of provided data with different c and
gamma values. Provides information useful for determining the optimal values for these parameters: the number of support
vectors used, the number of false positives and negatives, and the overall efficiency (or accuracy).  Note: provided data
should be separated in advance into equally-sized training and testing groups.  Further information on this, and other
uses for libsvm, can be found in the libsvm documentation.

To run: python trainandtest.py trainFile testFile resultFile
"""

# Modules to interface with the command line and time the program
from os import system as command
from subprocess import Popen, PIPE
from sys import argv
from time import time
from math import sqrt

# The training and testing sets, respectively
trainFile = argv[1]
testFile = argv[2]
resultFile = argv[3]

# Tables for our information: c and gamma values are
# selected in advance and used to calculate other values
Cs = [10 ** (float(n) / 4) for n in range(-12, 9)]
Gammas = [float(n) / 2 for n in range (2, 13)]
nSVs = []
FPFs = []
FNFs = []
efficiencies = []
distances = []
times = []

# Trains the SVM and saves the number of support vectors used
def train(c, gamma, trainFile):
	modelFile = trainFile + "model"
	trainCommand = ["../Packages/libsvm/svm-train", "-c", str(c), "-g", str(gamma), trainFile, modelFile]
	output = Popen(trainCommand, stdout = PIPE).communicate()[0]
        nSVs.append(int(output.split("Total nSV = ")[1]))
	return modelFile

# Tests the SVM on the test data set and removes now-unnecessary model files
def test(testFile, modelFile):
	predictionFile = testFile + "result"
	command("../Packages/libsvm/svm-predict " + testFile + " " + modelFile + " " + predictionFile)
	command("rm " + modelFile)
	return predictionFile

# Compares the predicted classes generated by the SVM with the actual
# classes of the test data, calculates and saves false positives,
# negatives, and efficiency, and deletes now-unnecessary prediction files
def compare(testFile, predictionFile):
	real = []	# Real data
	prediction = []	# Predicted data

	# Signal, background, false positive count, and false negative count
	signal = 0; background = 0
	FP = 0; FN = 0

	# Imports real and predicted data into lists
	with open(testFile, 'r') as rawReal:
		for line in rawReal:
			real.append(int(line.split()[0]))

	with open(predictionFile, 'r') as rawPrediction:
		for line in rawPrediction:
			prediction.append(int(line))

	# Checks for and increments signal, background, and false positives and negatives as necessary
	for i in range(len(real)):
		if real[i] == 1:
			signal += 1
		if real[i] == -1:
			background += 1
		if real[i] < prediction[i]:
			FP += 1
		elif real[i] > prediction[i]:
			FN += 1


	# Calculates false positive and negative
	# fraction, as well as overall efficiency
	if background == 0:
		if FP == 0:
			FPF = 0
		else:
			FPF = 1
	else:
		FPF = float(FP) / float(background)

	if signal == 0:
		if FN == 0:
			FNF = 0
		else:
			FNF = 1
	else:
		FNF = float(FN) / float(signal)
		
	efficiency = 1 - FNF
	# Distance from ideal result (efficiency = 1, FPF = 0) on plot of FPF vs. efficiency 
	distance = sqrt((FPF ** 2) + ((1 - efficiency) ** 2))

	FPFs.append(FPF)
	FNFs.append(FNF)
	efficiencies.append(efficiency)
	distances.append(distance)
	command("rm " + predictionFile)

# Runs all of the above functions to perform a
# full run of the SVM for a given c and gamma.
def trainAndTest(c, gamma, trainFile, testFile):
	startTime = time()
	modelFile = train(c, gamma, trainFile)
	predictionFile = test(testFile, modelFile)
	compare(testFile, predictionFile)
	times.append(time() - startTime)


# Performs a full SVM run for all of the given c and gamma
# values, saving all of the generated data in a new file
with open(resultFile, 'w') as results:
	i = 0
	for c in Cs:
		for gamma in Gammas:
			trainAndTest(c, gamma, trainFile, testFile)
			line = " ".join([str(c), str(gamma), str(nSVs[i]), str(FPFs[i]), str(FNFs[i]), str(efficiencies[i]), str(distances[i]), str(times[i]), "\n"])
			results.write(line)
			print "Progress: %(current)d/%(total)d" % {"current": i + 1, "total": len(Cs) * len(Gammas)} 
			i += 1