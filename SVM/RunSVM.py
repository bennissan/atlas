"""
RunSVM.py
Ben Nissan

Trains and tests support vector machines (or SVMs) with libsvm to classify a set of provided data with different c and
gamma values. Provides information useful for determining the optimal values for these parameters: the number of support
vectors used, the number of false positives and negatives, and the overall efficiency (or accuracy).  Note: provided data
should be separated in advance into equally-sized training and testing groups.  Further information on this, and other
uses for libsvm, can be found in the libsvm documentation.

To run: python trainandtest.py trainFile testFile resultFile
"""

from os import system as command
from subprocess import Popen, PIPE
from sys import argv, path
from time import time
from math import sqrt

path.append('../Packages/libsvm/python')
from svmutil import *

# The training and testing sets, respectively
trainFile = argv[1]
testFile = argv[2]
resultFile = argv[3]

# Tables for our information: c and gamma values are
# selected in advance and used to calculate other values
Cs = [10 ** (float(n) / 4) for n in range(-12, 9)]
Gammas = [float(n) / 2 for n in range (2, 13)]
nSVs = []
FPFs = []
FNFs = []
efficiencies = []
distances = []
times = []

trainClasses, trainData = svm_read_problem(trainFile)
trainProblem = svm_problem(trainClasses, trainData)

testClasses, testData = svm_read_problem(testFile)

# Compares the predicted classes generated by the SVM with the actual
# classes of the test data, calculates and saves false positives,
# negatives, and efficiency, and deletes now-unnecessary prediction files
def compare(real, predicted):
        # Signal, background, false positive count, and false negative count
        signal = 0; background = 0
        FP = 0; FN = 0

        # Checks for and increments signal, background,
        # and false positives and negatives as necessary
        for i in range(len(real)):
                if real[i] == 1:
                        signal += 1
                if real[i] == -1:
                        background += 1
                if real[i] < predicted[i]:
                        FP += 1
                elif real[i] > predicted[i]:
                        FN += 1


        # Calculates false positive and negative
        # fraction, as well as overall efficiency
        if background == 0:
                if FP == 0:
                        FPF = 0
                else:
                        FPF = 1
        else:
                FPF = float(FP) / float(background)

        if signal == 0:
                if FN == 0:
                        FNF = 0
                else:
                        FNF = 1
        else:
                FNF = float(FN) / float(signal)
                
        efficiency = 1 - FNF
        # Distance from ideal result (efficiency = 1, FPF = 0) on plot of FPF vs. efficiency 
        distance = sqrt((FPF ** 2) + ((1 - efficiency) ** 2))

        FPFs.append(FPF)
        FNFs.append(FNF)
        efficiencies.append(efficiency)
        distances.append(distance)

# Runs all of the above functions to perform a
# full run of the SVM for a given c and gamma.
def trainAndTest(c, gamma, trainProblem, testClasses, testData):
        startTime = time()
        parameters = svm_parameter('-c ' + str(c) + ' -g ' + str(gamma))
        model = svm_train(trainProblem, parameters)
        nSVs.append(model.nSV[0] + model.nSV[1])
        predictedClasses, predictedAccuracy, predictedValues = svm_predict(testClasses, testData, model)
        times.append(time() - startTime)
        compare(testClasses, predictedClasses)


# Performs a full SVM run for all of the given c and gamma
# values, saving all of the generated data in a new file
with open(resultFile, 'w') as results:
        i = 0
        for c in Cs:
                for gamma in Gammas:
                        trainAndTest(c, gamma, trainProblem, testClasses, testData)
                        line = " ".join([str(c), str(gamma), str(FPFs[i]), str(FNFs[i]), str(efficiencies[i]), str(distances[i]), str(times[i]), "\n"])
                        results.write(line)
                        print "Progress: %(current)d/%(total)d" % {"current": i + 1, "total": len(Cs) * len(Gammas)} 
                        i += 1